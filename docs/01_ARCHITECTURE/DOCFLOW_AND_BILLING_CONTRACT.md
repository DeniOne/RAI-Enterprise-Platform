# CONTRACTS & INVOICING ARCHITECTURE (RAI HOLDING)

## ВВЕДЕНИЕ
Настоящий документ описывает архитектурный паттерн для реализации документооборота (договоры, накладные, акты, счета-фактуры) в условиях многопрофильного бизнеса (продажа ТМЦ, аренда, услуги) и сложной организационной структуры самого владельца платформы (RAI Holding).

Архитектура строго базируется на ранее принятом `PARTY_MANAGEMENT_CONTRACT.md`.
Документ отражает Institutional Grade подход: полная развязка юридических ролей, строгая событийность (Event-driven) исполнения обязательств и изоляция расчетов налогов (Tax Engine).

---

## 1. ПРИНЦИП "СВОИ И ЧУЖИЕ" (OUR COMPANIES)

Самая частая ошибка ERP-систем — делать разные таблицы для "наших юрлиц" (Our Companies) и "чужих юрлиц" (Customers/Suppliers).

**Императив:** В архитектуре RAI НЕТ разницы между своими и чужими.
Наши компании (ООО "РАИ Консалтинг", ООО "РАИ Аренда", ООО "РАИ АгроХимия") — это точно такие же записи в таблице `Party`, как и наши клиенты.

### Как система понимает, что это "Мы"?
У нас есть корневой Tenant (или системный узел). Все "наши" компании связаны с ним через домен `OWNERSHIP` с флагом `IS_HOST_COMPANY = true` (или отдельным relationType `HOST_SUBSIDIARY`).

**Формализация консолидации (Функция `isIntercompany`):**
`isIntercompany(sellerPartyId, buyerPartyId, asOf)` возвращает `true`, если оба узла принадлежат RAI Holding по отношению `OWNERSHIP` на дату `asOf`. 
Это делает консолидацию детерминированной и воспроизводимой в аудите.

**Эффект:** 
Мы можем заключать договоры МЕЖДУ своими компаниями (внутригрупповые обороты) абсолютно по тем же пайплайнам, что и с внешними клиентами. Ledger счастлив.

---

## 2. АРХИТЕКТУРА ДОКУМЕНТООБОРОТА (5 СЛОЕВ)

Разделяем процессы на строгие уровни: Соглашение (Contract) -> Обязательство (Obligation) -> Исполнение (Event) -> Требование (Invoice) -> Оплата (Payment).

### УРОВЕНЬ 1. CONTRACT (ДОГОВОР И РОЛИ СТОРОН)
Договор — это долгосрочная рамка. Мы отказываемся от жестких полей `sellerId` / `buyerId`, так как существуют агентские, трехсторонние и комиссионные схемы.

**Таблица: `Contract`**
- `id` (UUID)
- `tenantId`
- `type` (`CONSULTING`, `SALE_OF_GOODS`, `EQUIPMENT_LEASE`, `SERVICE_SLA`)
- `jurisdictionCode` (По праву какой страны судимся)
- `regulatoryProfileId` (Ссылка на профиль требований к документу)
- `validFrom` / `validTo`
- `status` (`DRAFT`, `SIGNED`, `TERMINATED`)

**Таблица: `ContractPartyRole` (Связь сторон с договором)**
- `id` (UUID)
- `contractId`
- `partyId`
- `role` (`SELLER` | `BUYER` | `LESSOR` | `LESSEE` | `AGENT` | `PRINCIPAL` | `PAYER` | `BENEFICIARY`)
- `isPrimary` (boolean, для отображения в UI)

**Таблица: `Obligation` (Обязательство)**
Порождается Договором. Бывает трех типов: `DELIVER` (поставить товар/услугу), `PAY` (оплатить), `PERFORM` (выполнить условие).
- `id` (UUID)
- `contractId`
- `type` (`DELIVER`, `PAY`, `PERFORM`)
- `status` (`OPEN`, `PARTIAL`, `FULFILLED`)

**Таблица: `BudgetReservation` (Резервирование бюджета)**
Для проактивного контроля перерасхода до выставления инвойсов.
- `id` (UUID)
- `contractId` / `obligationId`
- `amount`, `currency`
- `periodId`

**Таблица: `PaymentSchedule` (График платежей)**
Обеспечивает предсказуемость ДДС (Cashflow).
- `id` (UUID)
- `contractId` / `invoiceId`
- `dueDate`, `percentage`, `amount`

### УРОВЕНЬ 2. FULFILLMENT EVENT (ФАКТ ИСПОЛНЕНИЯ)
Это атомарные факты реального мира (Отгрузили канистры, трактор отработал смену, провели анализ почвы). 
**Императив:** События строго разделены по доменам, чтобы "акт услуги" коммерции не смешался с "внутренним перемещением" производства.

**Таблица: `FulfillmentEvent`**
- `id` (UUID)
- `obligationId` (Ссылка на конкретное обязательство)
- `eventDomain` (`COMMERCIAL` | `PRODUCTION` | `LOGISTICS` | `FINANCE_ADJ`)
- `eventType` (Специфика внутри домена, напр. `GOODS_SHIPMENT`, `INTERNAL_TRANSFER`)
- `regulatoryProfileId` (Валидатор реквизитов первичного документа)
- `date` (Дата факта)
- `assetId` (Если сдавали в аренду трактор — ссылка на трактор)
- `items` (JSONB / абстрактные слоты)
- `proofDocumentId` (IPFS-хэш или ссылка на скан подписанной ТТН/Акта)

**View-Model / Подтип: `StockMove` (Складской учет)**
Вычислимый слой (Stock Ledger) поверх `FulfillmentEvent`. Исключает необходимость превращать FulfillmentEvent в "бог-сущность".
- `fulfillmentEventId`
- `itemId`, `uom` (Единица измерения), `qty`
- `fromLocationId`, `toLocationId`
- `batchId` (Партия, серия, срок годности)

**Sub-Event: `RevenueRecognitionEvent`**
Выделенное событие признания выручки/себестоимости, отделенное от факта исполнения. Политика признания (по отгрузке, по переходу права собственности) задается через `recognitionPolicyId` в `RegulatoryProfile`.

### УРОВЕНЬ 3. INVOICE (НАПРАВЛЕНИЕ ТРЕБОВАНИЯ)
Инвойс — это зафиксированное финансовое требование, а не просто печатная форма "счета". Он строго типизирован по направлению движения денег (AR/AP).

**Таблица: `Invoice`**
- `id` (UUID)
- `contractId`
- `fulfillmentEventIds` (Массив ссылок на факты исполнения)
- `direction` (`AR` - Accounts Receivable (нам должны), `AP` - Accounts Payable (мы должны))
- `type` (`INVOICE`, `TAX_INVOICE` (Счет-фактура / ЭСЧФ))
- `subtotal`, `taxTotal`, `grandTotal`
- `status` (`DRAFT` → `ISSUED` → `POSTED` → `PARTIALLY_PAID` → `PAID` → `CLOSED`, `VOID`)

**Таблица: `RegulatoryArtifact` (Артефакты комплаенса)**
Контейнер под специфические данные регуляторов (например, коды Честного Знака, ВСД Меркурия, ФГИС Зерно), жестко привязанные к `Invoice` или `FulfillmentEvent`. Убирает хардкод из бизнес-логики.
- `id` (UUID)
- `sourceId` (Ссылка на Invoice / FulfillmentEvent)
- `artifactType` (`CHESTNY_ZNAK`, `MERCURY_VSD`, `FGIS_ZERNO`)
- `payloadRef` (JSON-структура или ссылка)
- `status`, `issuedAt`

**Поле сущности номенклатуры: `ProductTaxCode`**
Код ТН ВЭД или внутренний налоговый маркер для автоматизации RegulatoryProfile.

*Инвариант:* Переход в статус `POSTED` всегда инициирует создание `ledgerTxId` (или `ledgerEventId`).

### УРОВЕНЬ 4. PAYMENT & ALLOCATION (ОПЛАТЫ И РАЗНЕСЕНИЕ)
Слой оплат работает независимо от Инвойсов, позволяя учитывать авансы и частичные платежи.

**Таблица: `Payment` (Факт прохождения денег)**
- `id` (UUID)
- `payerPartyId`
- `payeePartyId`
- `amount`, `currency`
- `date`
- `paymentMethod` (`BANK_TRANSFER`, `CASH`, `OFFSET`)

**Таблица: `PaymentAllocation` (Связка денег и долга)**
- `id` (UUID)
- `paymentId`
- `invoiceId` (может быть null, если это чистый неразнесенный аванс)
- `allocatedAmount` (Сумма, закрывающая конкретный инвойс)

---

## 3. ПОДКЛЮЧЕНИЕ JURISDICTION AWARENESS (TAX ENGINE)

Мы категорически не хардкодим расчет НДС и не забиваем в код обещания типа "экспорт = 0%".

Когда создается `Invoice`, вызывается **Tax Engine** по строгому API контракту.

**TaxEngine.calculate(TaxContext):**
*Входные данные (Context):*
- `sellerJurisdiction`, `buyerJurisdiction`
- `supplyType` (`GOODS`, `SERVICE`, `LEASE`)
- `placeOfSupplyHints` (Где физически произошла отгрузка)
- `vatPayerFlags` (Плательщик ли НДС продавец/покупатель)
- `productTaxCode` (Код ТН ВЭД, если требуется)

*Выходные данные (TaxResult):*
- `rates` / `bases` (Ставки и расчетные базы)
- `exemptions` (Примененные освобождения)
- `regulatoryArtifacts` (Например: флаг "required_electronic_format: true")

---

## 4. КАК ЭТО ВЛИЯЕТ НА FRONTEND / UX

1. **Единый реестр Договоров (`Contracts`):**
   Интерфейс больше не опирается на жесткие колонки "Продавец" и "Покупатель". В карточке договора есть грид/список ролей сторон (`ContractPartyRole`).
2. **Типизация сделок:**
   Если выбран тип `EQUIPMENT_LEASE` (Аренда), UX динамически потребует выбрать актив (`Asset`) из нашего автопарка, который мы сдаем.
3. **Строгий Workflow (4 Шага):**
   Пользователь двигается по рельсам: `Рамка Договора -> Лента Исполнения (Акты/ТТН) -> Финансовое Требование (AR/AP) -> Разнесение Оплат`.
4. **Левое Меню CEO SPACE:**
   Нужно добавить блок **"Коммерция" (или "Документооборот")**:
   - Договоры (Рамки, Роли)
   - Исполнение (Лента событий `FulfillmentEvent`)
   - Финансы (Инвойсы AR/AP + Оплаты `Payment`)

---

## ВЫВОД И LEDGER КАНОН
Институциональная архитектура `Party Management` с легкостью проглатывает эту задачу. Наши компании — это просто особые `Party` в нашем графе. Разные виды бизнеса — это разные `ContractPartyRole`, порождающие разные `FulfillmentEvent`, которые сводятся в универсальные направления требований (`Invoice AR/AP`) и закрываются через механизмы аллокации (`PaymentAllocation`).

**Ledger-канон (Единый источник правды):** 
Модули CRM и Commerce хранят исключительно **бизнес-документы** (намерения контрактов, факты исполнения, выставленные инвойсы). 
Модуль **Ledger** хранит только неизменяемые финансовые и контрольные события (Double-entry / двойная запись), содержащие строгие ссылки на породившие их бизнес-документы (Invoice/Payment). 
Это исключает "двойной учёт" и споры о том, где находится истина. Система математически детерминирована.
