---
id: DOC-ARC-STD-058
layer: Architecture
type: Standards
status: draft
version: 1.0.0
---

1️⃣ Архитектурный профиль системы
Тип системы

Это event-driven, multi-module enterprise core на NestJS + Prisma.

Слои:

Application layer (Controllers)

Domain orchestration (Services)

Persistence (Prisma)

Event propagation (Outbox + EventEmitter2)

Background processing (Cron / Relay)

Система сложная. Это не CRUD-приложение.

2️⃣ Главная проблема архитектуры
Система построена на дисциплине, а не на инвариантах.

Это критический вывод.

Область	Сейчас	Тип
Multi-tenancy	manual companyId	Fail-open
Ledger	нет double-entry enforcement	Fail-open
FSM	нет DB constraints	Fail-open
Event delivery	at-least-once без dedupe	Fail-open

То есть:

система работает, пока разработчики не ошибаются

Enterprise-системы так не строятся.

3️⃣ Multi-Tenancy: реальное состояние
Что видно из отчёта

Нет Prisma middleware

Есть unguarded controllers

Есть raw SQL bypass

Есть модели без companyId, но tenant-scoped

Query-level фильтры ручные

Архитектурный вывод

Multi-tenancy не является системным контрактом.

Это локальное поведение сервисов.

Риск:

любой новый модуль может случайно открыть cross-tenant leak

тесты не гарантируют отсутствие утечки

нет централизованного enforcement

Это слабое место №1.

4️⃣ Финансовый контур (самая опасная зона)

Из раздела V:

Нет двойной записи

Нет балансовых проверок

Нет DB-level immutability

Нет idempotency

Это означает:

Финансовая модель арифметически не защищена.

Риск сценариев:

параллельные записи → расхождение баланса

повтор события → двойная проводка

ручной update → изменение истории

Для enterprise это критический блокер.

Это слабое место №2.

5️⃣ FSM Enforcement

FSM реализованы в сервисах.

Но:

нет DB constraints

нет запрета прямого update статуса

нет transition-guard на уровне persistence

Это означает:

Любой прямой prisma.update может нарушить состояние.

Это архитектура “доверия к коду”, а не “защиты от кода”.

6️⃣ Event Architecture

Outbox есть. Это плюс.

Но:

polling every second

raw SQL

нет consumer idempotency

EventEmitter2 in-process

Вывод

Система масштабируется вертикально, но не гарантирует:

cross-instance ordering

exactly-once semantics

deterministic replay

Это средний уровень зрелости.

7️⃣ Coupling

IntegrityModule импортирует:

ConsultingModule

TelegramModule

Это повышает уровень связанности ядра.

Потенциальный эффект:

каскадные изменения

усложнение изоляции модулей

Но циклов нет — это плюс.

8️⃣ Сильные стороны системы

Чтобы анализ был честным:

✔ Модульная декомпозиция зрелая

41 модуль — это управляемая композиция.

✔ Транзакции активно используются

29 $transaction — это правильно.

✔ Outbox pattern реализован

Это лучше, чем прямой EventEmitter.

✔ Концепция оркестрации есть

ConsultingOrchestrator, YieldOrchestrator — архитектурно правильно.

9️⃣ Реальный уровень зрелости

По шкале:

Уровень	Описание
1	Стартап хаос
2	Модульный backend
3	Domain-driven core
4	Enterprise invariant-driven
5	Financial-grade deterministic system

Система сейчас на границе 2 → 3.

Чтобы стать уровнем 4:

Multi-tenancy fail-closed

Ledger invariants

DB-level FSM enforcement

Idempotent event consumption

1️⃣0️⃣ Самый важный системный вывод

У вас:

Архитектура сложная
Но гарантий целостности меньше, чем кажется

Это типичная фаза зрелости:

система уже большая

но фундаментальные инварианты ещё не закреплены

1️⃣1️⃣ Риск-профиль

Если нагрузка ×3
или
если 2 команды начнут активно писать код

→ вероятность утечки или финансового несоответствия резко возрастёт.

1️⃣2️⃣ Что эта система сейчас?

Это:

стратегический ядро

оркестрационный backend

не полностью защищённая enterprise-платформа

1️⃣3️⃣ Ключевой вопрос

Вы хотите:

Развивать функциональность дальше
или

Зафиксировать фундамент инвариантов?

Потому что сейчас дальнейший рост будет увеличивать технический риск.
