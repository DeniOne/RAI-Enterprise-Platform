/**
 * Store Eligibility Guards
 * Module 08 — MatrixCoin-Economy
 * PHASE 0 — STORE (ELIGIBILITY LOGIC)
 * 
 * ⚠️ STRICT: Blocks access if invariants fail.
 * Throws explicit domain errors.
 */

import { StoreEligibilityContext, StoreEligibilityDeniedReason } from '../core/store.types';
import { MCState } from '../core/mc.types';
import { MCLifecycleState, StoreAccessDeniedReason, StoreEligibilityStatus } from '../core/economy.enums';
// @ts-ignore
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { StoreEligibilityService } from '../services/store-eligibility.service';
import { MCSnapshotRepository } from '../services/persistence.repositories';
import { AuditEventRepository } from '../services/audit-event.repository';

// ============================================================================
// ERROR CLASSES
// ============================================================================

export class StoreEligibilityError extends Error {
    constructor(
        public readonly reason: StoreEligibilityDeniedReason,
        message: string
    ) {
        super(message);
        this.name = 'StoreEligibilityError';
    }
}

// ============================================================================
// GUARDS
// ============================================================================

/**
 * Guard: System is operational
 */
export function guardSystemOperational(isMaintenance: boolean): void {
    if (isMaintenance) {
        throw new StoreEligibilityError(
            StoreAccessDeniedReason.SYSTEM_MAINTENANCE,
            'System is in maintenance mode. Store access denied.'
        );
    }
}

/**
 * Guard: User is not restricted
 */
export function guardUserNotRestricted(isRestricted: boolean): void {
    if (isRestricted) {
        throw new StoreEligibilityError(
            StoreAccessDeniedReason.USER_RESTRICTED,
            'User is restricted from accessing Store.'
        );
    }
}

/**
 * Guard: Context is valid
 */
export function guardValidContext(context: StoreEligibilityContext): void {
    if (!context.userId || !context.mcSnapshot) {
        throw new StoreEligibilityError(
            StoreAccessDeniedReason.INVALID_CONTEXT,
            'Invalid store eligibility context: Missing userId or mcSnapshot.'
        );
    }
}

/**
 * Validates individual MC for Store usage eligibility
 * Returns true if usable, false if not (e.g. Frozen/Expired).
 * DOES NOT THROW. Used by Logic to filter.
 */
export function isMCUsableForStore(mc: MCState, now: Date): boolean {
    // Must be ACTIVE
    if (mc.lifecycleState !== MCLifecycleState.ACTIVE) return false;

    // Must not be Frozen
    if (mc.isFrozen) return false;

    // Must not be Expired
    if (mc.expiresAt <= now) return false;

    return true;
}
/**
 * NestJS Guard Wrapper
 * Uses StoreEligibilityService to validate access.
 */
@Injectable()
export class StoreEligibilityGuard implements CanActivate {
    constructor(
        private readonly eligibilityService: StoreEligibilityService,
        private readonly snapshotRepo: MCSnapshotRepository,
        private readonly auditRepo: AuditEventRepository
    ) { }

    async canActivate(context: ExecutionContext): Promise<boolean> {
        const request = context.switchToHttp().getRequest();
        const userId = request.headers['x-user-id'] || (request.user?.id); // Fallback to Auth payload

        if (!userId) return false;

        // 1. Get Snapshot
        const snapshot = await this.snapshotRepo.findUserSnapshot(userId);

        // 2. Evaluate
        const result = this.eligibilityService.evaluateStoreEligibilityService({
            userId,
            mcSnapshot: snapshot,
            isSystemMaintenance: false, // Default or fetch from config
            isUserRestricted: false      // Fetch from User record if available
        });

        // 3. Save Audit Events generated by service
        for (const event of result.events) {
            await this.auditRepo.saveEvent(event);
        }

        // 4. Decision
        if (result.decision.status !== StoreEligibilityStatus.ELIGIBLE) {
            throw new StoreEligibilityError(
                result.decision.denialReason || StoreAccessDeniedReason.INVALID_CONTEXT,
                `Store Access Denied: ${result.decision.denialReason}`
            );
        }

        return true;
    }
}
