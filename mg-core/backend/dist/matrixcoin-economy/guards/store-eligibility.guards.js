"use strict";
/**
 * Store Eligibility Guards
 * Module 08 — MatrixCoin-Economy
 * PHASE 0 — STORE (ELIGIBILITY LOGIC)
 *
 * ⚠️ STRICT: Blocks access if invariants fail.
 * Throws explicit domain errors.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StoreEligibilityGuard = exports.StoreEligibilityError = void 0;
exports.guardSystemOperational = guardSystemOperational;
exports.guardUserNotRestricted = guardUserNotRestricted;
exports.guardValidContext = guardValidContext;
exports.isMCUsableForStore = isMCUsableForStore;
const economy_enums_1 = require("../core/economy.enums");
// @ts-ignore
const common_1 = require("@nestjs/common");
const store_eligibility_service_1 = require("../services/store-eligibility.service");
const persistence_repositories_1 = require("../services/persistence.repositories");
const audit_event_repository_1 = require("../services/audit-event.repository");
// ============================================================================
// ERROR CLASSES
// ============================================================================
class StoreEligibilityError extends Error {
    reason;
    constructor(reason, message) {
        super(message);
        this.reason = reason;
        this.name = 'StoreEligibilityError';
    }
}
exports.StoreEligibilityError = StoreEligibilityError;
// ============================================================================
// GUARDS
// ============================================================================
/**
 * Guard: System is operational
 */
function guardSystemOperational(isMaintenance) {
    if (isMaintenance) {
        throw new StoreEligibilityError(economy_enums_1.StoreAccessDeniedReason.SYSTEM_MAINTENANCE, 'System is in maintenance mode. Store access denied.');
    }
}
/**
 * Guard: User is not restricted
 */
function guardUserNotRestricted(isRestricted) {
    if (isRestricted) {
        throw new StoreEligibilityError(economy_enums_1.StoreAccessDeniedReason.USER_RESTRICTED, 'User is restricted from accessing Store.');
    }
}
/**
 * Guard: Context is valid
 */
function guardValidContext(context) {
    if (!context.userId || !context.mcSnapshot) {
        throw new StoreEligibilityError(economy_enums_1.StoreAccessDeniedReason.INVALID_CONTEXT, 'Invalid store eligibility context: Missing userId or mcSnapshot.');
    }
}
/**
 * Validates individual MC for Store usage eligibility
 * Returns true if usable, false if not (e.g. Frozen/Expired).
 * DOES NOT THROW. Used by Logic to filter.
 */
function isMCUsableForStore(mc, now) {
    // Must be ACTIVE
    if (mc.lifecycleState !== economy_enums_1.MCLifecycleState.ACTIVE)
        return false;
    // Must not be Frozen
    if (mc.isFrozen)
        return false;
    // Must not be Expired
    if (mc.expiresAt <= now)
        return false;
    return true;
}
/**
 * NestJS Guard Wrapper
 * Uses StoreEligibilityService to validate access.
 */
let StoreEligibilityGuard = class StoreEligibilityGuard {
    eligibilityService;
    snapshotRepo;
    auditRepo;
    constructor(eligibilityService, snapshotRepo, auditRepo) {
        this.eligibilityService = eligibilityService;
        this.snapshotRepo = snapshotRepo;
        this.auditRepo = auditRepo;
    }
    async canActivate(context) {
        const request = context.switchToHttp().getRequest();
        const userId = request.headers['x-user-id'] || (request.user?.id); // Fallback to Auth payload
        if (!userId)
            return false;
        // 1. Get Snapshot
        const snapshot = await this.snapshotRepo.findUserSnapshot(userId);
        // 2. Evaluate
        const result = this.eligibilityService.evaluateStoreEligibilityService({
            userId,
            mcSnapshot: snapshot,
            isSystemMaintenance: false, // Default or fetch from config
            isUserRestricted: false // Fetch from User record if available
        });
        // 3. Save Audit Events generated by service
        for (const event of result.events) {
            await this.auditRepo.saveEvent(event);
        }
        // 4. Decision
        if (result.decision.status !== economy_enums_1.StoreEligibilityStatus.ELIGIBLE) {
            throw new StoreEligibilityError(result.decision.denialReason || economy_enums_1.StoreAccessDeniedReason.INVALID_CONTEXT, `Store Access Denied: ${result.decision.denialReason}`);
        }
        return true;
    }
};
exports.StoreEligibilityGuard = StoreEligibilityGuard;
exports.StoreEligibilityGuard = StoreEligibilityGuard = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [store_eligibility_service_1.StoreEligibilityService,
        persistence_repositories_1.MCSnapshotRepository,
        audit_event_repository_1.AuditEventRepository])
], StoreEligibilityGuard);
